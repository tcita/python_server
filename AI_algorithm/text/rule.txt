1. 牌堆初始化

    牌堆构成：创建包含52个数字的列表，每个数字从1到13，每个数字严格重复4次（共13×4=52个元素）。

    示例：牌堆包含 [1,1,1,1,2,2,2,2,...,13,13,13,13]。

2. 抽取序列A和B

    抽取规则：

        序列A：从牌堆中不放回随机抽取6个数字 且A中不允许有重复的数字 。

        序列B：从剩余46个数字中不放回随机抽取3个数字。

    关键约束：

        每个数字在A和B中的总出现次数不超过4次（由牌堆初始化保证）。

3. 处理序列B

    处理顺序：

        每次模拟中，B的3个元素的处理顺序是完全随机的（通过随机打乱B的顺序实现）。

    插入规则：

        对于当前处理的元素x：

            插入位置：

                若序列A非空：将x插入到当前A的任意两个元素之间,开头,或末尾（共A.size()+1个合法位置）。



                    例如：A为 {a,b,c} 时，合法插入位置为 [1,2,3]（对应插入到a之前,a|b间、b|c间、c之后 共4个位置）。

                若序列A为空：直接将x加入A。

    匹配规则：

        搜索匹配元素y（与x值相同的元素）：

            向左搜索：从插入位置的前一个元素（索引pos-1）开始向左扫描，尝试找到y。

            向右搜索：从插入位置的后一个元素（索引pos）开始向右扫描，尝试找到y。


        无匹配：若找不到y，得分为0，不移除任何元素。

    得分计算与更新：

        区间和计算：若找到匹配，计算x与y之间所有元素的和（包含x和y）。

        移除区间：从A中移除匹配区间内的所有元素（包括x和y）。

        动态更新：每次插入操作后，A立即更新为移除后的新序列。

4. 回合得分计算

    累计三次插入操作的得分之和，作为当前回合的得分。

    示例：

        第一次插入得分5，第二次得分0，第三次得分6 → 回合得分11。



关键规则验证示例
场景：插入位置验证

    原A：{1,2,3,7,4,6}（长度6）。

    插入1到位置2：

        合法插入位置为1-6（实际插入到位置2，即元素2和3之间）。

        新A：{1,2,1,3,7,4,6}。


        
目标 ：用AI 算法完成这个功能，训练出的模型能求给定A,B的最大回合得分 给出完整代码